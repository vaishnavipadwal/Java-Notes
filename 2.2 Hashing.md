# **Hashing in Java**

**Hashing** is a technique used to uniquely identify a data element by associating it with a fixed-size value (called a **hash code**) generated through a **hash function**. In Java, hashing plays a critical role in the performance of data structures like **`HashSet`**, **`HashMap`**, and **`Hashtable`**.

### **How Hashing Works:**
- A **hash function** takes an input (or "key") and returns a fixed-size string of characters or a numerical value, which is the **hash code**. This hash code determines where the key-value pair will be placed in memory.
- **Collisions**: When two different keys generate the same hash code, it is called a **collision**. Java handles collisions by using techniques like **chaining** (linked lists) or **open addressing** (probing).

### **HashCode and Equals Methods:**
- Every object in Java inherits the **`hashCode()`** and **`equals()`** methods from the `Object` class.
  - **`hashCode()`**: Returns an integer value that represents the object’s hash code. It's used to determine the object’s bucket location in the hash table.
  - **`equals()`**: Determines whether two objects are equal. It is important to override this method when you override `hashCode()`.

**Contract Between `hashCode()` and `equals()`**:
- If two objects are equal according to the `equals()` method, they must have the same hash code.
- If two objects have the same hash code, they may or may not be equal (this is where collisions happen).

### **HashMap and HashSet in Java**
Both **`HashMap`** (for key-value pairs) and **`HashSet`** (for unique values) rely on hashing to perform operations like add, remove, and search efficiently.

- **`HashMap`**: It stores data in key-value pairs. It uses the key’s hash code to determine where to store the value.
- **`HashSet`**: It only stores values (not key-value pairs) and uses the hash code of the values to determine their location.

### **Key Operations with Hashing**

1. **Insertion**:
   - When you insert a key into a `HashMap` or `HashSet`, the **hash code** of the key is calculated.
   - The key-value pair is then inserted into a bucket based on the hash code.

2. **Search**:
   - When you search for a key, its **hash code** is recalculated, and the corresponding bucket is accessed directly. If there is a collision, Java checks for equality using the `equals()` method.

3. **Deletion**:
   - When deleting an element, Java uses the hash code to locate the correct bucket. If there’s a collision, the program checks for equality using `equals()`.

### **Example of Hashing in Java using HashMap and HashSet**

#### **Using HashMap**

```java
import java.util.*;

class HashMapExample {
    public static void main(String[] args) {
        // Create a HashMap to store employee ID (key) and name (value)
        HashMap<Integer, String> employeeMap = new HashMap<>();

        // Insert data into HashMap
        employeeMap.put(101, "Alice");
        employeeMap.put(102, "Bob");
        employeeMap.put(103, "Charlie");

        // Display the HashMap
        System.out.println("Employee HashMap: " + employeeMap);

        // Search for a value using the key
        String employeeName = employeeMap.get(102);  // Returns "Bob"
        System.out.println("Employee with ID 102: " + employeeName);

        // Remove an entry by key
        employeeMap.remove(101);
        System.out.println("HashMap after removing employee 101: " + employeeMap);
    }
}
```

#### **Using HashSet**

```java
import java.util.*;

class HashSetExample {
    public static void main(String[] args) {
        // Create a HashSet to store unique employee names
        HashSet<String> employeeSet = new HashSet<>();

        // Insert data into HashSet
        employeeSet.add("Alice");
        employeeSet.add("Bob");
        employeeSet.add("Charlie");

        // Display the HashSet
        System.out.println("Employee HashSet: " + employeeSet);

        // Search for an element
        boolean exists = employeeSet.contains("Bob");
        System.out.println("Does Bob exist in the set? " + exists);

        // Remove an element
        employeeSet.remove("Alice");
        System.out.println("HashSet after removing Alice: " + employeeSet);
    }
}
```

### **Hashing in Custom Objects**
To use custom objects (like a `Person` class) in a `HashMap` or `HashSet`, you must override the **`hashCode()`** and **`equals()`** methods to ensure that objects are placed in the correct bucket and comparisons are done correctly.

#### **Custom Object Example with HashMap**

```java
import java.util.*;

class Person {
    String name;
    int age;

    // Constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Override hashCode
    @Override
    public int hashCode() {
        return name.hashCode() + age;
    }

    // Override equals
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && name.equals(person.name);
    }

    @Override
    public String toString() {
        return name + ": " + age;
    }
}

class HashMapWithCustomObject {
    public static void main(String[] args) {
        // Create a HashMap with custom objects
        HashMap<Person, String> personMap = new HashMap<>();

        // Create Person objects
        Person p1 = new Person("Alice", 25);
        Person p2 = new Person("Bob", 30);

        // Insert into HashMap
        personMap.put(p1, "Engineer");
        personMap.put(p2, "Doctor");

        // Display the HashMap
        System.out.println("Person HashMap: " + personMap);

        // Search for a person by key
        String occupation = personMap.get(p1);
        System.out.println("Occupation of Alice: " + occupation);
    }
}
```

